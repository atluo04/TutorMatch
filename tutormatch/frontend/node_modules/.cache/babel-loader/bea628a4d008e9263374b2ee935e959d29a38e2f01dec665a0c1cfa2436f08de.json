{"ast":null,"code":"import { mixNumber } from '../../utils/mix/number.mjs';\nimport { complex } from '../../value/types/complex/index.mjs';\nconst correctBoxShadow = {\n  correct: (latest, {\n    treeScale,\n    projectionDelta\n  }) => {\n    const original = latest;\n    const shadow = complex.parse(latest);\n    // TODO: Doesn't support multiple shadows\n    if (shadow.length > 5) return original;\n    const template = complex.createTransformer(latest);\n    const offset = typeof shadow[0] !== \"number\" ? 1 : 0;\n    // Calculate the overall context scale\n    const xScale = projectionDelta.x.scale * treeScale.x;\n    const yScale = projectionDelta.y.scale * treeScale.y;\n    shadow[0 + offset] /= xScale;\n    shadow[1 + offset] /= yScale;\n    /**\n     * Ideally we'd correct x and y scales individually, but because blur and\n     * spread apply to both we have to take a scale average and apply that instead.\n     * We could potentially improve the outcome of this by incorporating the ratio between\n     * the two scales.\n     */\n    const averageScale = mixNumber(xScale, yScale, 0.5);\n    // Blur\n    if (typeof shadow[2 + offset] === \"number\") shadow[2 + offset] /= averageScale;\n    // Spread\n    if (typeof shadow[3 + offset] === \"number\") shadow[3 + offset] /= averageScale;\n    return template(shadow);\n  }\n};\nexport { correctBoxShadow };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}