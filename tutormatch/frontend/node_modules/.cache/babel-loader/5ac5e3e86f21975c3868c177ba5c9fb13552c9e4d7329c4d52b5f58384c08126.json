{"ast":null,"code":"import { Feature } from '../Feature.mjs';\nimport { observeIntersection } from './observers.mjs';\nconst thresholdNames = {\n  some: 0,\n  all: 1\n};\nclass InViewFeature extends Feature {\n  constructor() {\n    super(...arguments);\n    this.hasEnteredView = false;\n    this.isInView = false;\n  }\n  startObserver() {\n    this.unmount();\n    const {\n      viewport = {}\n    } = this.node.getProps();\n    const {\n      root,\n      margin: rootMargin,\n      amount = \"some\",\n      once\n    } = viewport;\n    const options = {\n      root: root ? root.current : undefined,\n      rootMargin,\n      threshold: typeof amount === \"number\" ? amount : thresholdNames[amount]\n    };\n    const onIntersectionUpdate = entry => {\n      const {\n        isIntersecting\n      } = entry;\n      /**\n       * If there's been no change in the viewport state, early return.\n       */\n      if (this.isInView === isIntersecting) return;\n      this.isInView = isIntersecting;\n      /**\n       * Handle hasEnteredView. If this is only meant to run once, and\n       * element isn't visible, early return. Otherwise set hasEnteredView to true.\n       */\n      if (once && !isIntersecting && this.hasEnteredView) {\n        return;\n      } else if (isIntersecting) {\n        this.hasEnteredView = true;\n      }\n      if (this.node.animationState) {\n        this.node.animationState.setActive(\"whileInView\", isIntersecting);\n      }\n      /**\n       * Use the latest committed props rather than the ones in scope\n       * when this observer is created\n       */\n      const {\n        onViewportEnter,\n        onViewportLeave\n      } = this.node.getProps();\n      const callback = isIntersecting ? onViewportEnter : onViewportLeave;\n      callback && callback(entry);\n    };\n    return observeIntersection(this.node.current, options, onIntersectionUpdate);\n  }\n  mount() {\n    this.startObserver();\n  }\n  update() {\n    if (typeof IntersectionObserver === \"undefined\") return;\n    const {\n      props,\n      prevProps\n    } = this.node;\n    const hasOptionsChanged = [\"amount\", \"margin\", \"root\"].some(hasViewportOptionChanged(props, prevProps));\n    if (hasOptionsChanged) {\n      this.startObserver();\n    }\n  }\n  unmount() {}\n}\nfunction hasViewportOptionChanged({\n  viewport = {}\n}, {\n  viewport: prevViewport = {}\n} = {}) {\n  return name => viewport[name] !== prevViewport[name];\n}\nexport { InViewFeature };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}